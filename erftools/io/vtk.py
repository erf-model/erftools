import numpy as np
import struct

def write_binary_vtk_cartesian_file(filename,
                                    x_grid, y_grid, z_grid,
                                    nz, k_to_delete, is_shift,
                                    point_data=None,
                                    velocity=None):
    """
    Writes a binary VTK file for a structured grid.

    Args:
    filename (str): Name of the VTK file to write.
    x_grid, y_grid, z_grid (numpy.ndarray): 3D arrays of grid coordinates.
    point_data (dict, optional): Dictionary of scalar data associated with the grid points.
    """

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)

    nrow, ncol = x_grid.shape
    nzval = nz

    print(ncol, nrow)

    with open(filename, 'wb') as f:
          # Write the VTK header
        f.write(b'# vtk DataFile Version 3.0\n')
        f.write(b'Generated by Python script\n')
        f.write(b'BINARY\n')
        f.write(b'DATASET STRUCTURED_GRID\n')
        f.write(f'DIMENSIONS {ncol} {nrow} {nzval}\n'.encode())
        f.write(f'POINTS {ncol * nrow * nzval} float\n'.encode())

        # Write grid points
        #points = np.stack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel()), axis=-1)
        #f.write(struct.pack('>' + 'f' * points.size, *points.ravel()))

        # TODO: rewrite without nested loops for efficiency?

        # Write grid points using a nested for loop
        for k in range(nz):
            z = np.mean(z_grid[:, :, k])
            for j in range(nrow):
                for i in range(ncol):
                    x = x_grid[j, i]
                    y = y_grid[j, i]
                    f.write(struct.pack('>fff', x, y, z))

        # Write point data (if any)
        if point_data:
            f.write(f'POINT_DATA {ncol * nrow * nzval}\n'.encode())
            for name, data in point_data.items():
                f.write(f'SCALARS {name} float 1\n'.encode())
                f.write(b'LOOKUP_TABLE default\n')
                for k in range(nz):  # Iterate over the z-dimension
                    for j in range(nrow):  # Iterate over the y-dimension
                        for i in range(ncol):  # Iterate over the x-dimension
                            value = data[i, j, k]
                            f.write(struct.pack('>f', value))

def write_binary_vtk_structured_grid(filename,
                                     x_grid, y_grid, z_grid,
                                     nz, k_to_delete, is_shift,
                                     zoffset=0.0,
                                     skip_latlon=True,
                                     point_data=None,
                                     velocity=None):
    """
    Writes a binary VTK file for a structured grid.

    Args:
    filename (str): Name of the VTK file to write.
    x_grid, y_grid, z_grid (numpy.ndarray): 3D arrays of grid coordinates.
    point_data (dict, optional): Dictionary of scalar data associated with the grid points.
    """

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)

    nx, ny = x_grid.shape
    nzval = nz - len(k_to_delete)

    print(nx, ny)

    with open(filename, 'wb') as f:
          # Write the VTK header
        f.write(b'# vtk DataFile Version 3.0\n')
        f.write(b'Generated by Python script\n')
        f.write(b'BINARY\n')
        f.write(b'DATASET STRUCTURED_GRID\n')
        f.write(f'DIMENSIONS {nx} {ny} {nzval}\n'.encode())
        f.write(f'POINTS {nx * ny * nzval} float\n'.encode())

        # Write grid points
        #points = np.stack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel()), axis=-1)
        #f.write(struct.pack('>' + 'f' * points.size, *points.ravel()))

        # TODO: rewrite without nested loops for efficiency?

        # Write grid points using a nested for loop
        for k in range(nz):
            z = np.mean(z_grid[:, :, nz-1-k]) + zoffset
            if nz-1-k in k_to_delete:
                print("Val is ", nz - 1 - k)
                continue;
            for j in range(ny):
                for i in range(nx):
                    x = x_grid[i, j]
                    y = y_grid[i, j]
                    f.write(struct.pack('>fff', x, y, z))

        # Write point data (if any)
        if point_data:
            f.write(f'POINT_DATA {nx * ny * nzval}\n'.encode())
            for name, data in point_data.items():
                if skip_latlon and (name == "latitude" or name=="longitude"):
                    continue;
                f.write(f'SCALARS {name} float 1\n'.encode())
                f.write(b'LOOKUP_TABLE default\n')
                for k in range(nz):  # Iterate over the z-dimension
                    if nz-1-k in k_to_delete:
                        continue;
                    for j in range(ny):  # Iterate over the y-dimension
                        for i in range(nx):  # Iterate over the x-dimension
                            value = data[nx-1-i, j, nz-1-k]
                            f.write(struct.pack('>f', value))

            # Write velocity vector field
            if velocity is not None:
                f.write("VECTORS velocity float\n".encode())
                for k in range(nz):
                    if nz-1-k in k_to_delete:
                        continue;
                    for j in range(ny):
                        for i in range(nx):
                            vx, vy, vz = velocity[nx-1-i, j, nz-1-k]
                            f.write(struct.pack('>fff',vx, vy, vz))
