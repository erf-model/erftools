import numpy as np
import struct


def write_binary_structured_vtk(filename,
                                x_grid, y_grid, z_grid,
                                point_data=None,
                                velocity=None,
                                indexing='xy',
                                k_to_delete=[],
                                mirrored_x=False,
                                top_down=False,
                                zoffset=0.0,
                                skip_latlon=False):
    """
    General function to write a binary VTK file on a structured grid.

    Arguments
    ---------
    filename : str
        Name of the VTK file to write.
    x_grid, y_grid, z_grid : numpy.ndarray
        2D, 2D, and 3D arrays of grid coordinates, respectively.
    point_data : dict, optional
        Dictionary of output scalar data associated with the grid points.
    velocity : numpy.ndarray, optional
        4D array (nx,ny,nz,3) of output velocity data.
    indexing : {'xy', 'ij'}, optional
        Input grid indexing, following numpy naming convention
    k_to_delete : list, optional
        Indices of vertical levels to exclude
    mirrored_x : bool, optional
        Output has the first index reversed.
    top_down : bool, optional
        Output has the last index reversed.
    zoffset : float, optional
        Offset to apply to output grid in z direction.
    skip_latlon : bool, optional
        If point_data are given, skip writing 'latitude' and
        'longitude' fields.
    """
    assert indexing in ('xy','ij') # Cartesian or matrix (row,col)

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)

    # Get grid extents
    if indexing == 'xy':
        nx, ny = x_grid.shape
    elif indexing == 'ij':
        ny, nx = x_grid.shape
    nz = z_grid.shape[2]
    print('nx, ny, nz =', nx, ny, nz)

    nzval = nz - len(k_to_delete)

    # Setup loop indices
    irange = range(nx-1,-1,-1) if mirrored_x else range(nx)
    krange = range(nz-1,-1,-1) if top_down else range(nz)

    with open(filename, 'wb') as f:
        # Write the VTK header
        f.write(b'# vtk DataFile Version 3.0\n')
        f.write(b'Generated by Python script\n')
        f.write(b'BINARY\n')
        f.write(b'DATASET STRUCTURED_GRID\n')
        f.write(f'DIMENSIONS {nx} {ny} {nzval}\n'.encode())
        f.write(f'POINTS {nx * ny * nzval} float\n'.encode())

        # TODO: rewrite without nested loops for efficiency?

        # Write grid points
        #points = np.stack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel()), axis=-1)
        #f.write(struct.pack('>' + 'f' * points.size, *points.ravel()))

        # Write grid points using a nested for loop
        for k in krange: # loop may be reversed
            if k in k_to_delete:
                print("Val is ", k)
                continue

            z = np.mean(z_grid[:, :, k]) + zoffset

            if indexing == 'xy':
                for j in range(ny):
                    for i in range(nx):
                        x = x_grid[i, j]
                        y = y_grid[i, j]
                        f.write(struct.pack('>fff', x, y, z))
            elif indexing == 'ij':
                for j in range(ny):
                    for i in range(nx):
                        x = x_grid[j, i] # indices flipped
                        y = y_grid[j, i]
                        f.write(struct.pack('>fff', x, y, z))

        # Write point data (if any)
        if point_data is not None:
            f.write(f'POINT_DATA {nx * ny * nzval}\n'.encode())
            for name, data in point_data.items():
                if skip_latlon and (name == "latitude" or name=="longitude"):
                    continue
                f.write(f'SCALARS {name} float 1\n'.encode())
                f.write(b'LOOKUP_TABLE default\n')
                for k in krange:  # Iterate over the z-dimension (may be reversed)
                    if k in k_to_delete:
                        continue
                    for j in range(ny):  # Iterate over the y-dimension
                        for i in irange:  # Iterate over the x-dimension (may be reversed)
                            value = data[i, j, k]
                            f.write(struct.pack('>f', value))

        # Write velocity vector field
        if velocity is not None:
            f.write("VECTORS velocity float\n".encode())
            for k in krange: # may be reversed
                if k in k_to_delete:
                    continue
                for j in range(ny):
                    for i in irange: # may be reversed
                        vx, vy, vz = velocity[i, j, k]
                        f.write(struct.pack('>fff', vx, vy, vz))


# formerly `write_binary_vtk_structured_grid`
def write_binary_vtk_on_native_grid(filename,
                                    x_grid, y_grid, z_grid,
                                    k_to_delete=[],
                                    point_data=None,
                                    velocity=None,
                                    **kwargs):
    if point_data is not None:
        # don't write out lat,lon
        point_data = {
            k:v for k,v in point_data.items()
            if k not in ['latitude','longitude']
        }
    return write_binary_structured_vtk(
            filename,
            x_grid, y_grid, z_grid,
            point_data=point_data,
            velocity=velocity,
            indexing='xy',
            k_to_delete=k_to_delete,
            mirrored_x=True,
            top_down=True,
            **kwargs)

# formerly `write_binary_vtk_cartesian_file`
def write_binary_vtk_on_cartesian_grid(filename,
                                       x_grid, y_grid, z_grid,
                                       point_data=None,
                                       **kwargs):
    return write_binary_structured_vtk(
            filename,
            x_grid, y_grid, z_grid,
            point_data=point_data,
            indexing='ij',
            mirrored_x=False,
            top_down=False,
            **kwargs)


def write_vtk_map(x, y, ids, filename, zlo=1e-12,
                  point_data=None):
    """
    Write an ASCII polydata VTK file containing borders for specified
    regions.

    Parameters:
        x (list or ndarray): x coordinates
        y (list or ndarray): y coordinates
        ids (list or ndarray): state/country/region indices
            corresponding to each (x, y)
        filename (str): Name of the output VTK file.
        zlo (float): constant elevation value
        point_data (dict): scalar data associated with points, optional
    """
    x = np.asarray(x)
    y = np.asarray(y)
    ids = np.asarray(ids)

    if len(x) != len(y) or len(x) != len(ids):
        raise ValueError("The length of x, y, and ids must be the same.")

    # Open VTK file for writing
    with open(filename, 'w') as vtk_file:
        # Write VTK header
        vtk_file.write("# vtk DataFile Version 3.0\n")
        vtk_file.write("State borders\n")
        vtk_file.write("ASCII\n")
        vtk_file.write("DATASET POLYDATA\n")

        # Group points by region
        unique_ids = np.unique(ids)
        points = []  # List of all points
        lines = []  # List of all lines

        # Process each region
        for region in unique_ids:
            region_indices = np.where(ids == region)[0]
            region_points = [(x[i], y[i]) for i in region_indices]
            start_idx = len(points)  # Starting index for this region's points
            points.extend(region_points)

            # Create line segments connecting adjacent points
            for i in range(len(region_points) - 1):
                lines.append((start_idx + i, start_idx + i + 1))

        # Write points
        vtk_file.write(f"POINTS {len(points)} float\n")
        for px, py in points:
            vtk_file.write(f"{px} {py} {zlo}\n")

        # Write lines
        vtk_file.write(f"LINES {len(lines)} {3 * len(lines)}\n")
        for p1, p2 in lines:
            vtk_file.write(f"2 {p1} {p2}\n")

        # Write point data (optional)
        if point_data is not None:
            vtk_file.write(f"POINT_DATA {len(points)}\n")

            for name, values in point_data.items():
                assert len(values) == len(points)
                vtk_file.write(f"SCALARS {name} double\n")
                vtk_file.write("LOOKUP_TABLE default\n")
                valstr = '\n'.join([f"{val:.14g}" for val in values])
                vtk_file.write(valstr+'\n')
