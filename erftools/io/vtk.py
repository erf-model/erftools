import numpy as np
import struct


def write_binary_structured_vtk(filename,
                                x_grid, y_grid, z_grid,
                                point_data=None,
                                velocity=None,
                                indexing='xy',
                                k_to_delete=[],
                                mirrored_x=False,
                                top_down=False,
                                zoffset=0.0,
                                skip_latlon=False):
    """
    General function to write a binary VTK file on a structured grid.

    Arguments
    ---------
    filename : str
        Name of the VTK file to write.
    x_grid, y_grid, z_grid : numpy.ndarray
        2D, 2D, and 3D arrays of grid coordinates, respectively.
    point_data : dict, optional
        Dictionary of output scalar data associated with the grid points.
    velocity : numpy.ndarray, optional
        4D array (nx,ny,nz,3) of output velocity data.
    indexing : {'xy', 'ij'}, optional
        Input grid indexing, following numpy naming convention
    k_to_delete : list, optional
        Indices of vertical levels to exclude
    mirrored_x : bool, optional
        Output has the first index reversed.
    top_down : bool, optional
        Output has the last index reversed.
    zoffset : float, optional
        Offset to apply to output grid in z direction.
    skip_latlon : bool, optional
        If point_data are given, skip writing 'latitude' and
        'longitude' fields.
    """
    assert indexing in ('xy','ij') # Cartesian or matrix (row,col)

    x_grid = np.asarray(x_grid)
    y_grid = np.asarray(y_grid)

    # Get grid extents
    if indexing == 'xy':
        nx, ny = x_grid.shape
    elif indexing == 'ij':
        ny, nx = x_grid.shape
    nz = z_grid.shape[2]
    print('nx, ny, nz =', nx, ny, nz)

    nzval = nz - len(k_to_delete)

    # Setup loop indices
    irange = range(nx-1,-1,-1) if mirrored_x else range(nx)
    krange = range(nz-1,-1,-1) if top_down else range(nz)

    with open(filename, 'wb') as f:
        # Write the VTK header
        f.write(b'# vtk DataFile Version 3.0\n')
        f.write(b'Generated by Python script\n')
        f.write(b'BINARY\n')
        f.write(b'DATASET STRUCTURED_GRID\n')
        f.write(f'DIMENSIONS {nx} {ny} {nzval}\n'.encode())
        f.write(f'POINTS {nx * ny * nzval} float\n'.encode())

        # TODO: rewrite without nested loops for efficiency?

        # Write grid points
        #points = np.stack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel()), axis=-1)
        #f.write(struct.pack('>' + 'f' * points.size, *points.ravel()))

        # Write grid points using a nested for loop
        for k in krange: # loop may be reversed
            if k in k_to_delete:
                print("Val is ", k)
                continue

            z = np.mean(z_grid[:, :, k]) + zoffset

            if indexing == 'xy':
                for j in range(ny):
                    for i in range(nx):
                        x = x_grid[i, j]
                        y = y_grid[i, j]
                        f.write(struct.pack('>fff', x, y, z))
            elif indexing == 'ij':
                for j in range(ny):
                    for i in range(nx):
                        x = x_grid[j, i] # indices flipped
                        y = y_grid[j, i]
                        f.write(struct.pack('>fff', x, y, z))

        # Write point data (if any)
        if point_data is not None:
            f.write(f'POINT_DATA {nx * ny * nzval}\n'.encode())
            for name, data in point_data.items():
                if skip_latlon and (name == "latitude" or name=="longitude"):
                    continue
                f.write(f'SCALARS {name} float 1\n'.encode())
                f.write(b'LOOKUP_TABLE default\n')
                for k in krange:  # Iterate over the z-dimension (may be reversed)
                    if k in k_to_delete:
                        continue
                    for j in range(ny):  # Iterate over the y-dimension
                        for i in irange:  # Iterate over the x-dimension (may be reversed)
                            value = data[i, j, k]
                            f.write(struct.pack('>f', value))

        # Write velocity vector field
        if velocity is not None:
            f.write("VECTORS velocity float\n".encode())
            for k in krange: # may be reversed
                if k in k_to_delete:
                    continue
                for j in range(ny):
                    for i in irange: # may be reversed
                        vx, vy, vz = velocity[i, j, k]
                        f.write(struct.pack('>fff', vx, vy, vz))


# formerly `write_binary_vtk_structured_grid`
def write_binary_vtk_on_native_grid(filename,
                                    x_grid, y_grid, z_grid,
                                    k_to_delete=[],
                                    point_data=None,
                                    velocity=None,
                                    **kwargs):
    if point_data is not None:
        # don't write out lat,lon
        point_data = {
            k:v for k,v in point_data.items()
            if k not in ['latitude','longitude']
        }
    return write_binary_structured_vtk(
            filename,
            x_grid, y_grid, z_grid,
            point_data=point_data,
            velocity=velocity,
            indexing='xy',
            k_to_delete=k_to_delete,
            mirrored_x=True,
            top_down=True,
            **kwargs)

# formerly `write_binary_vtk_cartesian_file`
def write_binary_vtk_on_cartesian_grid(filename,
                                       x_grid, y_grid, z_grid,
                                       point_data=None,
                                       **kwargs):
    return write_binary_structured_vtk(
            filename,
            x_grid, y_grid, z_grid,
            point_data=point_data,
            indexing='ij',
            mirrored_x=False,
            top_down=False,
            **kwargs)
